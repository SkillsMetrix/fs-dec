package com.pack.kafkaApp;

import java.util.HashMap;
import java.util.Map;

import org.apache.kafka.clients.producer.Partitioner;
import org.apache.kafka.common.Cluster;
import org.apache.kafka.common.utils.Utils;
import org.slf4j.helpers.Util;

public class CustomPartitioner implements Partitioner {

	private final Map<String, Integer> keyToPartition = new HashMap<>();

	@Override
	public void configure(Map<String, ?> configs) {
		keyToPartition.put("important-key", 0); // forcing to par-1
		keyToPartition.put("billing-key", 1); // forcing to par-1

	}

	@Override
	public int partition(String topic, Object keyObj, byte[] keyBytes, Object value, byte[] valueBytes,
			Cluster cluster) {
		int numPartitions = cluster.partitionCountForTopic(topic);
		if (keyObj == null) {
			return Utils.toPositive((value == null ? 0 : value.hashCode())) % numPartitions;
		}
		String key = keyObj.toString();

		// 1) exact mapping
		if (keyToPartition.containsKey(key)) {
			int p = keyToPartition.get(key);
			// safety : ensure p is a valid partion index
			if (p >= 0 && p < numPartitions)
				return p;
		}
		// 2) prefix rule : key starting with VIP- go to partion 2
		if (key.startsWith("vip-")) {
			int p = 2 % numPartitions;
			return p;
		}
		// 3) Default : hash the key)
		if (keyBytes != null) {
			return Utils.toPositive(Utils.murmur2(keyBytes)) % numPartitions;
		} else {
			return Utils.toPositive(key.hashCode()) % numPartitions;
		}

	}

	@Override
	public void close() {

	}

}
